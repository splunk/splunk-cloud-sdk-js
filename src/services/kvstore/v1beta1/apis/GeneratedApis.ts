// tslint:disable
/**
 * Copyright 2022 Splunk, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"): you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * KV Store API
 * With the Splunk Cloud KV store service in Splunk Cloud Services, you can save and retrieve data within your Splunk Cloud apps, enabling you to manage and maintain state in your application.
 *
 * OpenAPI spec version: v1beta1.2 (recommended default)
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



import {
    ErrorResponse,
    IndexDefinition,
    IndexDescription,
    PingResponse,
    Record,
} from '../models';
import BaseApiService from "../../../../baseapiservice";
import { KVStoreServiceExtensions } from "../../../../service_extensions/kvstore";
import { SplunkError, RequestStatus } from '../../../../client';

export const KVSTORE_SERVICE_PREFIX: string = '/kvstore/v1beta1';
export const KVSTORE_SERVICE_CLUSTER: string = 'api';

/**
 * KV Store API
 * Version: v1beta1.2
 * With the Splunk Cloud KV store service in Splunk Cloud Services, you can save and retrieve data within your Splunk Cloud apps, enabling you to manage and maintain state in your application.
 */
export class GeneratedKVStoreService extends BaseApiService {
    getServiceCluster() : string {
        return KVSTORE_SERVICE_CLUSTER
    }

    getServicePrefix() : string {
        return KVSTORE_SERVICE_PREFIX;
    }
    /**
     * Creates an index on a collection.
     * @param collection The name of the collection.
     * @param indexDefinition
     * @param args parameters to be sent with the request
     * @param requestStatusCallback callback function to listen to the status of a request
     * @return IndexDescription
     */
    public createIndex = (collection: string, indexDefinition?: IndexDefinition, args?: object, requestStatusCallback?: (requestStatus: RequestStatus) => void): Promise<IndexDescription> => {
        if (!indexDefinition) {
            throw new SplunkError({ message: `Bad Request: indexDefinition is empty or undefined` });
        }
        const path_params = {
            collection: collection
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}/indexes`(path_params);
        return this.client.post(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), indexDefinition, { query: args, statusCallback:  requestStatusCallback})
            .then(response => response.body as IndexDescription);
    }
    /**
     * Removes an index from a collection.
     * @param collection The name of the collection.
     * @param index The name of the index.
     * @param args parameters to be sent with the request
     * @param requestStatusCallback callback function to listen to the status of a request
     */
    public deleteIndex = (collection: string, index: string, args?: object, requestStatusCallback?: (requestStatus: RequestStatus) => void): Promise<object> => {
        const path_params = {
            collection: collection,
            index: index
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}/indexes/${'index'}`(path_params);
        return this.client.delete(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: args, statusCallback:  requestStatusCallback})
            .then(response => response.body as object);
    }
    /**
     * Deletes a record with a given key.
     * @param collection The name of the collection.
     * @param key The key of the record.
     * @param args parameters to be sent with the request
     * @param requestStatusCallback callback function to listen to the status of a request
     */
    public deleteRecordByKey = (collection: string, key: string, args?: object, requestStatusCallback?: (requestStatus: RequestStatus) => void): Promise<object> => {
        const path_params = {
            collection: collection,
            key: key
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}/records/${'key'}`(path_params);
        return this.client.delete(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: args, statusCallback:  requestStatusCallback})
            .then(response => response.body as object);
    }
    /**
     * Removes records in a collection that match the query.
     * @param collection The name of the collection.
     * @param args parameters to be sent with the request
     * @param args.enableMvl Determines if the query needs to include results in multi valued fields
     * @param args.query Query JSON expression.
     * @param requestStatusCallback callback function to listen to the status of a request
     */
    public deleteRecords = (collection: string, args?: { enableMvl?: boolean, query?: string, [key: string]: any }, requestStatusCallback?: (requestStatus: RequestStatus) => void): Promise<object> => {
        const path_params = {
            collection: collection
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}/query`(path_params);
        return this.client.delete(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: args, statusCallback:  requestStatusCallback})
            .then(response => response.body as object);
    }
    /**
     * Returns a record with a given key.
     * @param collection The name of the collection.
     * @param key The key of the record.
     * @param args parameters to be sent with the request
     * @param requestStatusCallback callback function to listen to the status of a request
     * @return { [key: string]: any; }
     */
    public getRecordByKey = (collection: string, key: string, args?: object, requestStatusCallback?: (requestStatus: RequestStatus) => void): Promise<{ [key: string]: any; }> => {
        const path_params = {
            collection: collection,
            key: key
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}/records/${'key'}`(path_params);
        return this.client.get(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: args, statusCallback:  requestStatusCallback})
            .then(response => response.body as { [key: string]: any; });
    }
    /**
     * Inserts a record into a collection.
     * @param collection The name of the collection.
     * @param body Record to add to the collection, formatted as a JSON object.
     * @param args parameters to be sent with the request
     * @param requestStatusCallback callback function to listen to the status of a request
     * @return Record
     */
    public insertRecord = (collection: string, body: { [key: string]: any; }, args?: object, requestStatusCallback?: (requestStatus: RequestStatus) => void): Promise<Record> => {
        const path_params = {
            collection: collection
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}`(path_params);
        return this.client.post(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), body, { query: args, statusCallback:  requestStatusCallback})
            .then(response => response.body as Record);
    }
    /**
     * Writes multiple records in a single request. If records have duplicate primary keys, only the last duplicate record will be written. If no errors occur, the response array will contain the keys of the written records, in no particular order.
     * @param collection The name of the collection.
     * @param requestBody Array of records to insert.
     * @param args parameters to be sent with the request
     * @param args.allowUpdates If allow_updates is false (default), the writes will be performed as a single INSERT. If any record already exists, the entire INSERT will fail and no records will be inserted. If allow_updates is true, the writes will be performed as a single INSERT ON CONFLICT. If one or more records already exists, said records will be updated and their _version's will be incremented. New records will be inserted with a _version of 0.
     * @param requestStatusCallback callback function to listen to the status of a request
     * @return Array<string>
     */
    public insertRecords = (collection: string, requestBody: Array<{ [key: string]: any; }>, args?: { allowUpdates?: boolean, [key: string]: any }, requestStatusCallback?: (requestStatus: RequestStatus) => void): Promise<Array<string>> => {
        const path_params = {
            collection: collection
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}/batch`(path_params);
        return this.client.post(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), requestBody, { query: args, statusCallback:  requestStatusCallback})
            .then(response => response.body as Array<string>);
    }
    /**
     * Returns a list of all indexes on a collection.
     * @param collection The name of the collection.
     * @param args parameters to be sent with the request
     * @param requestStatusCallback callback function to listen to the status of a request
     * @return Array<IndexDefinition>
     */
    public listIndexes = (collection: string, args?: object, requestStatusCallback?: (requestStatus: RequestStatus) => void): Promise<Array<IndexDefinition>> => {
        const path_params = {
            collection: collection
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}/indexes`(path_params);
        return this.client.get(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: args, statusCallback:  requestStatusCallback})
            .then(response => response.body as Array<IndexDefinition>);
    }
    /**
     * Use key-value query parameters to filter fields. Fields are implicitly ANDed and values for the same field are implicitly ORed.
     * Returns a list of records in a collection with basic filtering, sorting, pagination and field projection.
     * @param collection The name of the collection.
     * @param args parameters to be sent with the request
     * @param args.count Maximum number of records to return.
     * @param args.fields Comma-separated list of fields to include or exclude. Format is `<field>:<include value>`. Valid include values are 1 for include, 0 for exclude with default being 1.
     * @param args.offset Number of records to skip from the start.
     * @param args.orderby Sort order. Format is `<field>:<sort order>`. Valid sort orders are 1 for ascending, -1 for descending.
     * @param requestStatusCallback callback function to listen to the status of a request
     * @return Array<{ [key: string]: any; }>
     */
    public listRecords = (collection: string, args?: { count?: number, fields?: Array<string>, offset?: number, orderby?: Array<string>, [key: string]: any }, requestStatusCallback?: (requestStatus: RequestStatus) => void): Promise<Array<{ [key: string]: any; }>> => {
        const path_params = {
            collection: collection
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}`(path_params);
        return this.client.get(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: args, statusCallback:  requestStatusCallback})
            .then(response => response.body as Array<{ [key: string]: any; }>);
    }
    /**
     * Returns the health status from the database.
     * @param args parameters to be sent with the request
     * @param requestStatusCallback callback function to listen to the status of a request
     * @return PingResponse
     */
    public ping = (args?: object, requestStatusCallback?: (requestStatus: RequestStatus) => void): Promise<PingResponse> => {
        const path = `/kvstore/v1beta1/ping`;
        return this.client.get(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: args, statusCallback:  requestStatusCallback})
            .then(response => response.body as PingResponse);
    }
    /**
     * Updates the record with a given key, either by inserting or replacing the record.
     * @param collection The name of the collection.
     * @param key The key of the record.
     * @param body Record to add to the collection, formatted as a JSON object.
     * @param args parameters to be sent with the request
     * @param requestStatusCallback callback function to listen to the status of a request
     * @return Record
     */
    public putRecord = (collection: string, key: string, body: { [key: string]: any; }, args?: object, requestStatusCallback?: (requestStatus: RequestStatus) => void): Promise<Record> => {
        const path_params = {
            collection: collection,
            key: key
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}/records/${'key'}`(path_params);
        return this.client.put(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), body, { query: args, statusCallback:  requestStatusCallback})
            .then(response => response.body as Record);
    }
    /**
     * Returns a list of query records in a collection.
     * @param collection The name of the collection.
     * @param args parameters to be sent with the request
     * @param args.count Maximum number of records to return.
     * @param args.enableMvl Determines if the query needs to include results in multi valued fields
     * @param args.fields Comma-separated list of fields to include or exclude. Format is `<field>:<include value>`. Valid include values are 1 for include, 0 for exclude with default being 1.
     * @param args.offset Number of records to skip from the start.
     * @param args.orderby Sort order. Format is `<field>:<sort order>`. Valid sort orders are 1 for ascending, -1 for descending.
     * @param args.query Query JSON expression.
     * @param args.shared Indicates whether to return records only for the user specified in the Splunk-User-Id header or for the default user as well. Only valid if Splunk-User-Id is specified
     * @param requestStatusCallback callback function to listen to the status of a request
     * @return Array<{ [key: string]: any; }>
     */
    public queryRecords = (collection: string, args?: { count?: number, enableMvl?: boolean, fields?: Array<string>, offset?: number, orderby?: Array<string>, query?: string, shared?: boolean, [key: string]: any }, requestStatusCallback?: (requestStatus: RequestStatus) => void): Promise<Array<{ [key: string]: any; }>> => {
        const path_params = {
            collection: collection
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}/query`(path_params);
        return this.client.get(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: args, statusCallback:  requestStatusCallback})
            .then(response => response.body as Array<{ [key: string]: any; }>);
    }
    /**
     * Deletes all the records in a collection.
     * @param collection The name of the collection.
     * @param args parameters to be sent with the request
     * @param requestStatusCallback callback function to listen to the status of a request
     */
    public truncateRecords = (collection: string, args?: object, requestStatusCallback?: (requestStatus: RequestStatus) => void): Promise<object> => {
        const path_params = {
            collection: collection
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}/truncate`(path_params);
        return this.client.delete(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: args, statusCallback:  requestStatusCallback})
            .then(response => response.body as object);
    }
}
export type KVStoreService = GeneratedKVStoreService & KVStoreServiceExtensions;
export const KVStoreService = KVStoreServiceExtensions(GeneratedKVStoreService);
